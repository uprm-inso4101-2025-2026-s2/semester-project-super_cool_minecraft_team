= Project Proposal: Minecraft Dependency Visualizer
University of Puerto Rico at Mayagüez
Department of Computer Science and Engineering
ICOM4009 | INSO4101 | Introduction to Software Engineering
:toc:
:toclevels: 4
:sectnums:
:icons: font

== 1. Informative

=== 1.1 Name, Place and Date

* Name: Minecraft Dependency Visualizer
* Place: University of Puerto Rico at Mayagüez
* Date: February 2026

=== 1.2 Team Members

==== 1.2.1 Managers

* Harry Y. Ruiz-Figueroa
* Juan J. Pumarejo Bello
* Victor E. Ravelo Santana

==== 1.2.2 Team Leaders

* Team A
** Zabdiel J. Valentin-Perez
** Karilys A. Muñiz-Ramos
* Team B
** Gabriel A. Sanchez-Santos
** Ricardo Burgos
* Team C
** Victor M De Jesús
** Javier M. Aguilo Agosto

==== 1.2.3 Team Members

* Team A
** Christian J Berberena
** Julian A. Laracuente-Matos
** Yahir J. Reyes-Padilla
** Alondra Soto-Feliciano
** Andrews Y. Molina-Matos
** Carlos A. Negron-Ramirez
** Roberto J. Fuertes-Casse
** Sergio A. Cartagena-Reyes
** Nathalie M. Castro-Mojica
** Merced J. Rivera-Mercado
** Isamar Z. Garcia-Rivera
* Team B
** Joyson J. Martinez-Andujar
** Lorenzo Ramos-Martinez
** Wesley M. Rodriguez-Mojica
** Andres M. Roldan-Hanke
** Jordan O. DeLeon-Orama
** Manuel O. Vazquez-Rodriguez
** Kevin L. Ruiz-Sanchez
** Jan E. Ramos-Vazquez
** Cheselyn Morales-Santiago
* Team C
** Alexander M. Garcia
** Edgar Y. Colon-Sanchez
** Hector J. Vale-Melendez
** Jaiden X. Roman-Mejias
** Booker A. Robinson
** David Semidoy
** Hector G. Ramos-Cortes

=== 1.3 Current Situation

Minecraft mods rely on other mods, loaders, libraries, and specific Minecraft versions; these are the mod dependencies.
If these dependencies are not met, the game will crash or fail to launch.
This leads to user frustration and wasted time.
These dependencies are not easy to access; while it would be better to have them on the main download page, they are usually provided as plain text in metadata or in dedicated wikis that less-experienced users may not find.

=== 1.4 Needs and Ideas

We identify that many Minecraft mods rely on other mods, libraries, specific loaders, and specific Minecraft versions in order to function correctly.
When dependencies are missing, incompatible, or incorrectly ordered, the game often fails to launch or crashes during runtime.

There is a significant lack of accessibility in dependency documentation.
Currently, users are forced to parse technical plain text, which is particularly exclusionary for younger audiences who make up a large portion of the Minecraft community.
Furthermore, most mods do not display dependencies or incompatibilities clearly on their main mod pages.
Users need a way to understand these dependencies and conflicts without technical barriers, so they do not abandon using Minecraft mods due to confusion or frustration.

There is, therefore, a need for a mod dependency visualization platform that allows users to explore mods and their dependencies in a clear and intuitive way.
Users need to see which mods depend on a selected mod and understand why each dependency is required.
The team will develop a comprehensive web-based platform designed to transform the way Minecraft players interact with mod configurations.
The approach is to move away from text-heavy logs and provide a Dynamic Dependency Graph.
This will make conflict detection visual and easy to manage for all users.

=== 1.5 Concepts

* Concept 1: Mod (Entity) +
  A packaged software extension for Minecraft that adds or changes gameplay functionality and declares metadata such as version, supported Minecraft and Mod Loader versions, and dependency constraints.
* Concept 2: Modpack (Entity) +
  A selected set of Mods intended to run together under a specific Minecraft version and Mod Loader, whose correctness depends on satisfying all declared constraints.
* Concept 3: Dependency (Relation) +
  A directed requirement from one Mod to another Mod or library indicating that the target must be present and satisfy any stated Version Constraint for the source Mod to operate correctly within a Modpack.
* Concept 4: Incompatibility (Relation) +
  A declared constraint between two Mods or specific versions stating they must not coexist in the same Modpack due to functional or version conflicts.
* Concept 5: Version Constraint (Attribute) +
  A rule attached to a Dependency or Incompatibility declaration that specifies which versions of a target Mod are acceptable.
* Concept 6: Dependency Resolution (Behavior) +
  The process of determining whether a Modpack satisfies all required Dependencies, including transitive ones, and does not violate declared Incompatibilities or Version Constraints.

=== 1.6 Scope and Span

==== 1.6.1 Project Scope

* This project operates within the domain of gaming software tooling, specifically targeting the Minecraft Java Edition modding ecosystem.
* Minecraft modding involves the integration of community-developed modifications that extend or alter gameplay, requiring understanding of complex dependency relationships between mod files, mod loaders, and game versions.
* The project addresses the broader challenge of dependency management and mod compatibility analysis, areas where existing tooling is either too technical for general users or entirely absent.
* The scope encompasses domain engineering, requirements engineering, software architecture, and the design and development of a web-based dependency visualization platform that makes mod management more accessible and understandable for a non-technical audience.

==== 1.6.2 Project Span

* The platform will target users of Minecraft Java Edition using either the Fabric or Forge mod loaders, the two most widely adopted modding frameworks for the game.
* It will support the analysis of individual mod files and medium-sized modpacks, defined as collections typically ranging from a handful of mods up to roughly one hundred.
* Mod metadata will be sourced from CurseForge and Modrinth, the two primary mod distribution repositories for Minecraft.
* The platform will classify mods by runtime context, distinguishing between client-side, host-side, and client-host-sided mods.
* Dependencies will be resolved transitively and classified as required, optional, or incompatible.
* Where metadata is available, the platform will surface known version incompatibilities and link users to the relevant CurseForge or Modrinth pages for missing or outdated dependencies.
* The platform will function strictly as a decision-support tool and will not modify the user's game installation or launch the game.

===== 1.6.2.1 Inclusions

The project will focus on the design, development, and evaluation of a web-based proof-of-concept platform for visualizing Minecraft mod dependencies.
The core activities included in the project span:

* Platform Development: Create an interactive, browser-based prototype that visualizes mods as nodes and their dependencies as directed edges in a graph data structure.
  The platform will be designed to support a curated dataset of mods, rather than attempting to index the entire CurseForge and Modrinth repositories.
* Metadata Parsing and Normalization: Develop scripts to programmatically parse dependency metadata from a preselected set of mods sourced from CurseForge and Modrinth.
  This includes identifying required dependencies, optional dependencies, and incompatible mod versions.
  The project will handle all mod metadata in accordance with ethical data handling principles, ensuring that any data acquisition, storage, and processing respects the terms of use and privacy expectations established by the source repositories.
  The data will then be normalized into a unified internal schema to manage inconsistencies between the two source platforms.
* Visual Highlighting of Critical Information: Implement visual cues within the graph interface to draw user attention to key issues.
  This will include distinct highlighting for missing dependencies, version incompatibilities, and optional relationships.
* Decision-Support Features: Enable users to interact with the graph and access relevant information.
  Upon selecting a specific mod node, the platform will display:
** Its direct and transitive dependents (i.e., which other mods rely on it).
** A plain-language explanation of its dependency requirements (e.g., "Required for game launch on the client-side").
** A simulation of the potential impact, highlighting which other mods would be affected if the selected mod were removed or updated.
* Evaluation with Sample Modpacks: Conduct a formal evaluation of the prototype's effectiveness using sample modpacks.

===== 1.6.2.2 Exclusions

To maintain a realistic scope and focus on the core problem of visualization and understanding, the following activities are explicitly excluded from the project span:

* Automated Installation or Management: The platform will function solely as a decision-support tool.
  It will not download, install, update, remove, or modify a user's Minecraft instance.
* Visual Highlighting of Critical Information: Implement visual cues within the graph interface to draw user attention to key launcher, MultiMC, Prism Launcher).
* Exhaustive Mod Indexing: The project will not attempt to index or visualize all mods available on CurseForge and Modrinth.
  The focus will be on a curated, representative dataset sufficient to demonstrate the platform's functionality and core features.
* Generalization to Other Games: Potential for future generalization is acknowledged (Section 6), but the development and testing of the prototype will be strictly confined to the Minecraft modding ecosystem.
* Addressing Runtime Errors: The project will not build a system that diagnoses live game crashes or reads Minecraft log files.
  Its purpose is preventative and analytical, focusing on understanding dependencies before launching the game.
* Commercial Deployment: The final deliverable will be a functional prototype for academic evaluation, not a production-ready, publicly hosted service.

===== 1.6.2.3 Key Focus Areas and Methodology

The project will be executed using an agile-inspired methodology suitable for a student team.
Work will be organized into iterative sprints, each focusing on a key deliverable.
The primary focus areas are:

* Data Acquisition & Modeling: Researching and implementing the parsing of metadata from CurseForge/Modrinth APIs and designing the internal graph data structure.
* Graph Visualization Engine: Selecting and implementing a suitable JavaScript library (e.g., D3.js, vis.js, Cytoscape.js) to render the interactive dependency graph.
* User Interface & Interaction: Designing and building the user interface components for displaying mod information, search, and selection, ensuring clarity and ease of use.
* Evaluation & Analysis: Defining success metrics, designing user test cases, conducting the evaluation, and analyzing the results to determine the project's success against the criteria outlined in Section 5.

===== 1.6.2.4 Timeline

The project milestones and key dates are as follows:

* Project A3 submissions: January 27 - 30
* Project selection: February 2
* First milestone ends: February 27
* Milestone 1 presentation: March 2
* Second milestone ends: April 3
* Milestone 2 presentation: April 6
* Final milestone ends: May 8
* Final milestone presentation: May 11

These dates define the structured time frame within which all planning, development, evaluation, and reporting activities will be conducted.
All deliverables and presentations will be completed in accordance with this timeline to ensure timely progress and academic review.

=== 1.7 Synopsis

Minecraft modding has become a common way for players to expand and personalize the game experience, but it also introduces a recurring challenge: many mods rely on other mods, libraries, specific loaders, and specific Minecraft versions in order to function correctly.
When these dependencies are missing, incompatible, or incorrectly ordered, Minecraft may fail to launch or crash during runtime.
This situation is often made worse by the lack of accessibility in dependency documentation, since users are frequently forced to interpret technical plain text and logs, and many mods do not clearly display their dependencies or incompatibilities on their main pages.
As a result, many users become frustrated and abandon the idea of using mods because they cannot easily understand what is going wrong.

To help diminish the effects of this problem, the team proposes the Minecraft Dependency Visualizer, a web-based platform intended to make dependency management more understandable and approachable.
The platform will represent mods as nodes and dependencies as directed connections, forming a Dynamic Dependency Graph that users can explore.
Users will be able to select a mod and view which mods depend on it, as well as why it is required within a configuration.
In addition, the platform will support identifying and signaling conflicts through incompatibility information, helping users recognize when certain mods cannot coexist in the same mod configuration.

At the core of the platform is the ability to analyze a user's selected mod collection (modpack) and validate it through dependency resolution and conflict analysis.
Dependencies will be classified into exactly one type—required, optional, or incompatible—and the platform will represent dependencies transitively, ensuring that dependencies of dependencies are also included.
By shifting the experience away from text-heavy troubleshooting and toward a clear visual representation, the Minecraft Dependency Visualizer aims to reduce confusion, improve accessibility for all users, and make modpack setup and maintenance significantly easier.

=== 1.8 Assumptions and Dependencies

* Assumption A: Reliable access to Minecraft mod metadata sources is available during development. +
  Dependency: The project depends on these sources to design and test dependency parsing and resolution logic. +
  Risk: If metadata access is disrupted or formats change, development may be delayed while adapting the tool.

* Assumption B: The project's requirements and scope will stay consistent during the development phase. +
  Dependency: Design choices and implementation plans depend on stable requirements to minimize the need for rework. +
  Risk: Major changes may affect the schedule and necessitate adjustments to key components.

* Assumption C: The necessary development tools, environments, and test data are accessible and correctly set up. +
  Dependency: The team depends on these resources to develop and test the dependency tool. +
  Risk: If these resources are unavailable or improperly configured, progress may be delayed and errors could be introduced.

=== 1.9 Implicit and Derived Goals

* Goal 1: Simplify and automate the management of Minecraft mods and libraries to ensure all dependencies are correctly installed and compatible, reducing errors and manual configuration for users.
* Goal 2: Provide a reliable system for detecting version conflicts and missing dependencies, enabling mod developers and players to maintain stable modpacks without technical troubleshooting.
* Goal 3: Offer optional features such as dependency visualization and compatibility suggestions to enhance user experience and improve modpack maintenance efficiency.

== 2. Descriptive

=== 2.1 Rough Sketch of the Domain

Many users frequently confuse the Fabric Loader with the Fabric API, leading to situations like a case where a player complained that their game wouldn't start because it was missing the API, despite having already installed the loader.
This confusion is tied to a general frustration with "Library mods," where an average player downloads a "main" mod but ignores the fact that it depends on three or four others, which in turn require specific matching versions of the API.
For example, a player tried to move his world to a later Minecraft version, but the game crashed immediately because his existing mod list didn't meet the new version's dependencies; he spent hours trying to find the right files before eventually giving up.
Furthermore, there is a segment of the audience that is interested in trying mods for the first time but lacks the technical knowledge to obtain them.
These users find that existing guides are not very explicit and assume they already know how to handle file directories or Java versions, leading many potential players to simply stop trying altogether to avoid the complexity and frustration of the installation process.

=== 2.2 Narrative

Within the mod ecosystem of Minecraft, users construct gameplay configurations by combining independently developed modifications, each of which declares structural constraints through metadata.
A mod specifies its identity, supported versions, required dependencies, optional dependencies, and declared incompatibilities.
When multiple mods are grouped into a modpack, they form a configuration whose validity depends on the collective satisfaction of all declared requirements and constraints.
Adding or removing a mod triggers domain behaviors such as dependency expansion through transitive requirements, compatibility evaluation, and conflict detection.
A configuration is considered structurally valid only if every required dependency is present in a compatible version and no declared incompatibilities exist among included mods.
These relationships can be abstracted as a dependency network in which mods participate in directed requirement relations and constraint relations.

=== 2.3 Requirements

==== Team C - Frontend (Mod Uploading) Requirements

* The system shall provide a user interface that allows the user to upload a modpack file or a supported mods folder.
* The system shall validate that the uploaded file is not empty and is in a supported format before processing.
* The system shall display real-time feedback during upload (idle, uploading, processing, success, error).
* The system shall prevent submission if validation fails and display a clear, user-friendly error message.
* The system shall allow the user to retry the upload process without restarting the application.
* The UI shall provide clear instructions describing how users can compress their modpack into a .zip file before uploading.

==== 2.3.1 Domain Requirements

This section derives requirements from observed properties of the Minecraft modding domain.
Each requirement is grounded in the domain narrative and domain events.

* DR-1 — Mod Identity: The system shall represent each Mod with an identifier and a version such that two Mods are distinguishable by (identifier, version).
* DR-2 — Declared Dependency Relationships: The system shall represent declared dependency relationships as directed relations from a source Mod to a target Mod.
* DR-3 — Dependency Type Exclusivity: The system shall classify each declared relationship between two Mods into exactly one of the following types: required, optional, or incompatible.
* DR-4 — Version Constraints: The system shall associate a version constraint to a dependency or incompatibility relation when such a constraint is declared.
* DR-5 — Structural Validity: The system shall determine whether a Modpack is structurally valid by verifying that:
** (a) all required dependencies are present,
** (b) no declared incompatibilities are violated,
** (c) all version constraints are satisfied.
* DR-6 — Transitive Dependency Closure: The system shall compute the transitive closure of required dependencies.
* DR-7 — Missing Dependency Identification: The system shall identify each missing required dependency in a Modpack.
* DR-8 — Incompatibility Detection: The system shall detect incompatibility violations in a Modpack.
* DR-9 — Circular Dependency Detection: The system shall detect circular dependency structures in the dependency network.
* DR-10 — Resolution Result: The system shall produce a resolution result identifying satisfied dependencies, missing dependencies, incompatibilities, version violations, and cycles.

==== 2.3.2 Personas

The following personas represent typical stakeholders who would use the mod dependency analyzer web application.
They justify the previously defined epics and user stories.

===== Persona 1 — "the Modpack Builder"

Profile:

* 20 - 25 years old
* Experienced Minecraft player
* Builds custom modpacks for personal use or friends
* Familiar with Fabric and mod loaders
* Comfortable with technical tools but values automation

Goals:

* Quickly detect missing dependencies
* Avoid version conflicts
* Export a clean, ready-to-run modpack
* Visualize how mods depend on each other

Frustrations:

* Manually tracking dependencies
* Broken modpacks due to missing or incompatible versions
* Searching multiple websites for correct download links

Why this persona matters: Alex justifies features such as automatic dependency detection, graph visualization, conflict resolution, and modpack re-packaging.

===== Persona 2 — "the Casual Player"

Profile:

* 16 - 22 years old
* Limited technical knowledge of mod loaders
* Downloads modpacks from friends or online communities
* Wants simple, reliable setup

Goals:

* Ensure all required mods are included
* Fix missing dependencies easily
* Avoid technical errors during installation

Frustrations:

* Game crashes due to missing mods
* Confusing download pages
* Not knowing which dependency version is correct

Why this persona matters: Sam justifies features like automatic download fetching, clear dependency previews, and guided fixes for missing mods.

===== Persona 3 — "the Server Organizer"

Profile:

* 22–30 years old
* Runs small multiplayer servers
* Manages shared modpacks for a group
* Needs consistency across players

Goals:

* Maintain a stable modpack
* Ensure all players use identical mod versions
* Quickly update packs when dependencies change

Frustrations:

* Version mismatches between players
* Manual updates for every change
* Lack of visibility into dependency chains

==== 2.3.3 Interface Requirements

* The subsystem must be capable of receiving dependency metadata from the Mod Uploading subsystem, including mod identifiers, version information, and declared dependencies.
* Queries to the Modrinth API (or similar repositories) should allow the system to locate required mods using dependency identifiers.
* Download URLs for compatible dependency versions must be retrieved and made available for installation.
* Structured results of the dependency resolution process are returned to the Visualization subsystem, including resolved dependencies, version matches, and any unresolved items.
* Notifications are provided whenever a required dependency cannot be resolved, ensuring the system or user is aware of the issue.
* Failed API requests should trigger automatic retries up to a configurable limit to maintain reliability.
* All interactions with external APIs are logged for debugging, verification, and auditing purposes.

==== 2.3.4 Machine Requirements

Performance:

* The subsystem shall process dependency resolution requests efficiently, ensuring reasonable response times under typical user workloads.
* The system shall support multiple simultaneous requests without significant performance degradation or instability.
* Retrieval of dependency metadata and download links shall be performed in a timely manner to maintain smooth workflow execution.
* The subsystem shall efficiently read and analyze modpack contents, including individual mod files, to detect dependencies and incompatibilities.

Reliability:

* The subsystem shall maintain stable operation during normal usage, with minimal downtime.
* External API failures shall be handled gracefully, ensuring partial failures do not crash the system or corrupt stored data.
* Errors and exceptions shall be logged to support debugging, testing, and verification activities.

Resource and Stability:

* The subsystem shall operate within reasonable CPU and memory limits to avoid negatively impacting other system components.
* The system shall ensure consistent behavior during extended processing tasks such as large modpack analysis.

Scalability:

* The system shall support growth in mod volume, dependency complexity, and user activity without requiring architectural redesign.
* The subsystem architecture shall allow integration of additional mod sources or APIs in future iterations.

=== 2.4 Terminology

This section defines the core terms that will be used throughout the project.
These definitions apply to both the backend dependency logic and the frontend graph interface.

Goal: Keep the language consistent across documentation and communication.

Each term includes:

* Classification (Entity, Relation, Attribute, Event, Behavior)
* Phase Introduced (Domain = Minecraft ecosystem concept, System = project-specific concept)
* Definition (Implementation-independent)

==== Dependency Resolution / Mod Graph Terminology

. Mod (Modification) +
  Classification: Entity +
  Phase Introduced: Domain +
  Definition: A mod (modification) is a packaged software extension that alters or adds functionality to Minecraft. A mod may introduce new content, mechanics, or systems and may declare dependencies or incompatibilities with other mods.

. Dependency +
  Classification: Relation +
  Phase Introduced: Domain +
  Definition: A dependency is a directed relationship in which one mod requires another mod in order to function correctly. If the required mod is missing or does not satisfy the stated version constraint, the dependent mod cannot operate as intended.

. Optional Dependency +
  Classification: Relation +
  Phase Introduced: Domain +
  Definition: A relationship where a mod can integrate with another mod if it is present, but does not require it for core functionality.

. Version +
  Classification: Attribute +
  Phase Introduced: Domain +
  Definition: A structured identifier assigned to a specific release of a mod. Versions are used to distinguish releases and evaluate compatibility between mods.

. Version Constraint +
  Classification: Attribute +
  Phase Introduced: Domain +
  Definition: A rule that specifies which versions of a mod are acceptable within a dependency relationship. A version constraint defines a valid range or condition that must be satisfied.

. Minecraft Version +
  Classification: Entity +
  Phase Introduced: Domain +
  Definition: A specific release of Minecraft and its updates. It defines the base environment and APIs that mods and mod loader target. Important for the compatibility constraint in the dependency graph.

. Mod Loader +
  Classification: Entity +
  Phase Introduced: Domain +
  Definition: A runtime framework responsible for loading and managing mods within Minecraft. A mod loader establishes compatibility rules and governs how mods are initialized and executed.

. Fabric +
  Classification: Entity +
  Phase Introduced: Domain +
  Definition: The mod loader to be used for this project. It provides the framework for loading mods.

. Mod Instance +
  Classification: Entity +
  Phase Introduced: System +
  Definition: A specific occurrence of a mod identified by name and version within the system. A mod instance represents a concrete node in the dependency graph.

. Mod pack +
  Classification: Entity +
  Phase Introduced: Domain +
  Definition: A collection of mod instances, their version, and associated configuration files.

. Dependency Graph +
  Classification: Entity +
  Phase Introduced: System +
  Definition: A directed graph structure that represents mod instances as nodes and dependency relationships as edges. The graph models how mods depend on one another.

. Node +
  Classification: Entity +
  Phase Introduced: System +
  Definition: A logical and visual representation of a mod instance within the dependency graph.

. Edge +
  Classification: Relation +
  Phase Introduced: System +
  Definition: A directed connection between two nodes that represents a dependency relationship.

. Resolution +
  Classification: Behavior +
  Phase Introduced: System +
  Definition: The process of evaluating whether all declared dependencies within a given mod set are satisfied according to version constraints and compatibility rules.

. Conflict +
  Classification: Event +
  Phase Introduced: System +
  Definition: A condition that occurs when dependency requirements or version constraints cannot be satisfied simultaneously. A conflict prevents successful resolution of the mod set.

. Compatibility +
  Classification: Attribute +
  Phase Introduced: Domain +
  Definition: The state in which two or more mods, versions, or loaders can operate together without violating declared dependencies or constraints.

. Installation State +
  Classification: Attribute +
  Phase Introduced: System +
  Definition: The current status of a mod instance within the managed environment, such as installed, missing, unresolved, or conflicting.

. Transitive Dependency +
  Classification: Relation +
  Phase Introduced: System +
  Definition: A dependency that arises indirectly through a chain of other dependencies. If Mod A depends on Mod B, and Mod B depends on Mod C, then Mod A has a transitive dependency on Mod C.

. Profile +
  Classification: Entity +
  Phase Introduced: System +
  Definition: A named container that stores a user's mod instances and their installation statuses.

==== Mod Uploading Terminology

* UploadSession +
  Classification: Entity +
  Phase: Domain +
  Definition: The complete process of uploading one or more mod files, from initial selection to final confirmation.

* ModFile +
  Classification: Entity +
  Phase: Domain +
  Definition: The actual game modification file being uploaded, typically in .jar, .zip, or .rar format.

* UploadQueue +
  Classification: Entity +
  Phase: System +
  Definition: A visual list component displaying all files selected for upload and their current processing status.

* UploadStatus +
  Classification: Attribute +
  Phase: System +
  Definition: The current state of an upload (idle, uploading, paused, completed, failed, or cancelled).

* FilePicker +
  Classification: Entity +
  Phase: System +
  Definition: A UI component that opens the system dialog for users to browse and select files from their computer.

* DragAndDropZone +
  Classification: Entity +
  Phase: System +
  Definition: A designated UI area where users can drag files directly from their desktop to initiate upload.

* FileSelected +
  Classification: Event +
  Phase: Domain +
  Definition: User action of choosing a file through the file picker dialog.

* FileDropped +
  Classification: Event +
  Phase: Domain +
  Definition: User action of dragging and releasing a file into the drag and drop zone.

* UploadStarted +
  Classification: Event +
  Phase: Domain +
  Definition: User action of initiating the upload process after file selection.

* UploadCancelled +
  Classification: Event +
  Phase: Domain +
  Definition: User action that aborts an ongoing file upload.

* UploadPaused +
  Classification: Event +
  Phase: Domain +
  Definition: User action that temporarily stops an active upload.

* UploadResumed +
  Classification: Event +
  Phase: Domain +
  Definition: User action that continues a paused upload.

* RetryUpload +
  Classification: Event +
  Phase: Domain +
  Definition: User action that attempts to upload a previously failed file again.

* UploadProgress +
  Classification: Attribute +
  Phase: System +
  Definition: Numerical value 0 - 100  indicating how much of a file has been successfully transferred.

* ProgressIndicator +
  Classification: Entity +
  Phase: System +
  Definition: Visual element showing upload completion percentage; can be a progress bar, spinner, or percentage text.

* FilePreview +
  Classification: Entity +
  Phase: System +
  Definition: Thumbnail, icon, or filename display representing the uploaded file.

* ValidationFeedback +
  Classification: Behavior +
  Phase: System +
  Definition: Visual messages displayed to users indicating if a selected file meets requirements.

* ValidationError +
  Classification: Attribute +
  Phase: System +
  Definition: A specific message indicating why a file was rejected (wrong format, too large, etc.).

* FileSizeWarning +
  Classification: Attribute +
  Phase: System +
  Definition: Notification that the selected file exceeds recommended size limits.

* UploadComplete +
  Classification: Event +
  Phase: Domain +
  Definition: Notification that all files have been successfully transferred to the server.

* MetadataForm +
  Classification: Entity +
  Phase: System +
  Definition: UI form where users can add additional information about the uploaded mod.

* CancelButton +
  Classification: Entity +
  Phase: System +
  Definition: UI element that allows users to abort an ongoing upload.

* TimeRemaining +
  Classification: Attribute +
  Phase: System +
  Definition: Estimated time display showing how long until upload completes.

* UploadSpeed +
  Classification: Attribute +
  Phase: System +
  Definition: Real-time display of data transfer rate during upload.

=== 2.5 Domain Entities

* Mod: Represents a Minecraft modification that extends the base game and may declare dependencies or incompatibilities.
* Dependency: Represents a directed requirement where one Mod depends on another Mod, possibly constrained by version.
* Incompatibility: Represents a conflict condition in which two Mods cannot coexist in the same Modpack.
* Modpack: Represents a collection of Mods intended to function together within a Minecraft instance.
* Dependency Graph: Represents the conceptual structure of Mods and their dependency relationships.
* User: Represents an individual who analyzes Modpacks and their dependencies.
* Dependency Resolution: Represents the process of identifying and retrieving required Mods for a Modpack.
* Mod Source: Represents an external repository from which Mods and their versions can be obtained.
* Download Task: Represents the retrieval of a specific Mod version required to satisfy a Dependency.
* Retrieved Mod: Represents a Mod successfully obtained to fulfill a Dependency requirement.
* Resolution Result: Represents the outcome of dependency analysis, indicating satisfied, missing, or conflicting Mods.

=== 2.6 Domain Functions

.A. Resolve Dependencies
. Collect dependency information declared by each Mod in a Modpack.
. Determine whether required dependencies are satisfied.
. Produce a Resolution Result summarizing satisfied, missing, and conflicting items.

.B. Find Missing Dependencies
. Compare required dependencies against the Mods included in the Modpack.
. List missing required dependencies in the Resolution Result.

.C. Detect Conflicts / Incompatibilities
. Check incompatibility rules when available.
. Identify mods that cannot coexist and record conflicts in the Resolution Result.

.D. Check Version Rules
. Verify that mod versions satisfy dependency version constraints.
. Record version mismatches in the Resolution Result.

.E. Locate Mod Sources
. Identify possible Mod Sources where missing dependencies can be found.
. Collect candidate references/versions from those sources.

.F. Create and Execute a Download Task
. Create a Download Task for a selected candidate reference.
. Retrieve the dependency as a Retrieved Mod (conceptually) for inclusion in the resolved configuration.

.G. Build and Export the Dependency Graph
. Add Mod nodes to the Dependency Graph.
. Add Dependency edges between Mods based on declared relationships.
. Avoid duplicate nodes/edges when building the graph.
. Export the Dependency Graph into a JSON representation for visualization.

=== 2.7 Domain Events

* Event 1: Modpack Provided for Analysis +
  Meaning: A modpack becomes available for dependency analysis. +
  After: Its metadata can be examined and its declared dependencies can be identified. +
  State Change: The modpack transitions from "not analyzed" to "analysis in progress."

* Event 2: Dependencies Identified +
  Meaning: All declared dependencies of included mods have been extracted from metadata. +
  After: Each dependency exists in normalized form and is classified as required, optional, incompatible, or version-constrained. +
  State Change: Dependency data transitions from "raw metadata" to "identified and classified."

* Event 3: Dependency Graph Exists +
  Meaning: A dependency graph representing all declared relationships among mods has been constructed. +
  After: All mods appear as nodes and their declared relationships exist as directed edges. +
  State Change: The modpack transitions to "dependency graph constructed."

* Event 4: Missing Dependency Exists +
  Meaning: A required dependency declared by a mod is not present in the modpack. +
  After: The configuration is incomplete. +
  State Change: The modpack transitions to "invalid missing required dependency."

* Event 5: Incompatibility Exists +
  Meaning: Two or more mods declare mutual incompatibility. +
  After: The configuration contains conflicting components. +
  State Change: The modpack transitions to "invalid incompatibility conflict."

* Event 6: Circular Dependency Exists +
  Meaning: A cycle exists in the dependency relationships among mods. +
  After: The dependency structure cannot be resolved hierarchically. +
  State Change: The modpack transitions to "invalid circular dependency."

* Event 7: Version Constraint Violation Exists +
  Meaning: A mod version does not satisfy the version constraints declared by dependent mods. +
  After: The configuration violates declared version requirements. +
  State Change: The modpack transitions to "invalid version constraint violation."

* Event 8: Transitive Dependencies Expanded +
  Meaning: Indirect dependencies (dependencies of dependencies) have been incorporated into the dependency structure. +
  After: The complete dependency chain exists. +
  State Change: The modpack transitions from "direct dependencies only" to "complete dependency closure."

* Event 9: Dependency Resolution Completed +
  Meaning: The process of resolving all declared dependencies has finished. +
  After: It is determined whether all required dependencies are satisfied. +
  State Change: The modpack transitions from "resolution in progress" to either "resolved successfully" or "resolution failed."

* Event 10: Dependency Has Become Unsatisfied +
  Meaning: A previously satisfied dependency becomes invalid due to mod removal, version change, or constraint violation. +
  After: The configuration no longer satisfies all declared requirements. +
  State Change: The modpack transitions from "dependency satisfied" to "dependency unsatisfied."

* Event 11: Modpack Configuration Validated +
  Meaning: All dependency, incompatibility, circularity, and version checks have completed successfully. +
  After: The modpack is structurally valid. +
  State Change: The modpack transitions to "valid configuration."

* Event 1: Modpack Uploaded +
  Triggered when: a user uploads a modpack or mod collection for analysis. +
  Outcome: The system initiates metadata parsing and begins extracting dependency information from all included mods. +
  State Change: The modpack transitions from "not analyzed" to "parsing in progress."

* Event 2: Dependencies Extracted +
  Triggered when: metadata parsing completes and all mod dependencies are successfully identified. +
  Outcome: The system classifies each dependency as required, optional, or incompatible and prepares data for graph construction. +
  State Change: Dependency data transitions from "raw metadata" to "normalized and classified."

* Event 3: Dependency Graph Generated +
  Triggered when: the system successfully constructs the dependency graph from normalized dependency data. +
  Outcome: The graph is made available for visualization and analysis, representing all mods as nodes and their relationships as directed edges. +
  State Change: The modpack analysis transitions to "graph ready for visualization."

* Event 4: Missing Dependency Detected +
  Triggered when: the system identifies that a mod declares a required dependency that is not present in the modpack. +
  Outcome: The system flags the missing dependency, identifies which mod requires it, and signals a critical configuration error. +
  State Change: The modpack configuration transitions to "invalid - missing required dependency."

* Event 5: Incompatibility Detected +
  Triggered when: the system identifies that two or more mods in the modpack declare mutual incompatibility. +
  Outcome: The system highlights the conflicting mods and the reason for incompatibility in the dependency graph. +
  State Change: The modpack configuration transitions to "invalid - incompatibility conflict."

* Event 6: Circular Dependency Detected +
  Triggered when: the system identifies a cycle in the dependency graph (e.g., Mod A requires Mod B, and Mod B requires Mod A). +
  Outcome: The system reports the circular dependency chain and prevents graph construction from entering an infinite loop. +
  State Change: The modpack configuration transitions to "invalid - circular dependency."

* Event 7: Version Constraint Violation Detected +
  Triggered when: a mod's version does not satisfy the version constraints specified by its dependent mods. +
  Outcome: The system identifies which mods have incompatible versions and suggests compatible alternatives or version updates. +
  State Change: The modpack configuration transitions to "invalid - version constraint violation."

* Event 8: Transitive Dependencies Resolved +
  Triggered when: the system expands the dependency graph to include all transitive dependencies (dependencies of dependencies). +
  Outcome: The complete dependency chain is made visible, showing not only direct dependencies but also indirect requirements. +
  State Change: The modpack representation transitions from "direct dependencies only" to "complete transitive dependency view."

* Event 9: Modpack Configuration Validated +
  Triggered when: all dependency checks, incompatibility checks, and version constraint validations complete successfully. +
  Outcome: The system marks the modpack as structurally valid and ready for use, providing a summary of all valid mods and dependencies. +
  State Change: The modpack configuration transitions to "valid and ready for deployment."

* Event 10: Mod Removed or Updated +
  Triggered when: a user modifies the modpack by removing a mod or updating an existing mod to a new version. +
  Outcome: The system recalculates the dependency graph, identifies new missing dependencies or incompatibilities, and updates the visualization. +
  State Change: The modpack configuration reverts to analysis mode and reassesses validity based on the new composition.

* Event 11: Dependency Graph Visualized +
  Triggered when: the system renders the dependency graph for user interaction and exploration. +
  Outcome: Users can select mods, view which mods depend on them, understand why dependencies are required, and explore impact of potential removals. +
  State Change: The modpack transitions from "analyzed" to "interactive visualization available."

* Event 12: Dependency Has Just Been Declared +
  Triggered when: a mod explicitly declares a required relationship with another mod within its metadata. +
  Outcome: The system records the dependency as a directed relationship in the dependency model and prepares it for validation and resolution. +
  State Change: The dependency model transitions from "no declared relationship" to "declared dependency recorded."

* Event 13: Mod Has Just Been Added To Modpack +
  Triggered when: a user adds a new mod to an existing modpack configuration. +
  Outcome: The system updates the modpack composition, re-evaluates declared dependencies and incompatibilities, and schedules dependency resolution if required. +
  State Change: The modpack configuration transitions from "stable composition" to "composition modified - revalidation required."

* Event 14: Dependency Resolution Has Just Been Completed +
  Triggered when: the system completes the process of resolving all declared dependencies for the current modpack configuration. +
  Outcome: The system determines whether all required mods are present and whether any dependencies remain unsatisfied. +
  State Change: The dependency resolution process transitions from "in progress" to either "resolved successfully" or "resolution failed."

* Event 15: Retrieved Mod Has Just Been Obtained +
  Triggered when: a required mod is successfully retrieved from a mod source to satisfy a previously declared dependency. +
  Outcome: The retrieved mod is added to the modpack configuration and incorporated into the dependency graph for further validation. +
  State Change: The modpack transitions from "dependency unsatisfied" to "dependency provisionally satisfied pending validation."

* Event 16: Dependency Has Just Become Unsatisfied +
  Triggered when: a previously satisfied dependency becomes invalid due to mod removal, version change, or constraint violation. +
  Outcome: The system flags the dependency as unsatisfied and initiates corrective actions such as retrieval suggestions or configuration warnings. +
  State Change: The modpack configuration transitions from "dependency satisfied" to "dependency unsatisfied."

* Event 17: Modpack Has Just Become Consistent +
  Triggered when: all declared dependencies are satisfied and no declared incompatibilities are violated within the modpack configuration. +
  Outcome: The system confirms the structural integrity of the modpack and allows it to proceed to validation or deployment stages. +
  State Change: The modpack configuration transitions from "inconsistent or under validation" to "consistent configuration state."

=== 2.8 Interface Requirements

* Allow users to upload mod files or submit mod metadata for processing.
* Validate uploaded metadata and report errors for missing or malformed entries.
* Provide client-side feedback and visual indicators during file upload.
* Implement responsive UI behavior to ensure usability across screen sizes.
* Allow users to visually explore mod dependency relationships through an interactive dependency graph.
* Allow users to select a mod and view its required, optional, and incompatible dependencies.
* Provide a search interface to locate mods by name or identifier.
* Display clear visual indicators to distinguish between satisfied, missing, and incompatible dependencies.
* Provide a detailed view panel showing information about the selected mod and its dependency relationships.
* Allow users to navigate between related mods directly from the dependency visualization.
* Provide clear feedback messages when dependency data cannot be loaded or is incomplete.
* Maintain consistent layout and labeling to ensure ease of understanding for non-technical users.

The system shall provide a user-friendly and responsive interface that supports the visualization and management of mod dependencies.
The interface must ensure clarity, accessibility, and usability for both technical and non-technical users.

.A. File Submission and Validation
. The system shall allow users to upload mod files or submit mod metadata for processing.
. The system shall validate uploaded metadata and report errors for missing or malformed entries.
. The interface shall provide visual feedback and progress indicators during file upload operations.

.B. Dependency Visualization
. The system shall provide an interactive dependency graph to visually explore mod relationships.
. Users shall be able to select a mod and view its required, optional, and incompatible dependencies.
. The interface shall display clear visual indicators distinguishing satisfied, missing, and incompatible dependencies.
. Users shall be able to navigate between related mods directly from the dependency visualization.

.C. Search and Information Display
. The system shall provide a search interface to locate mods by name or identifier.
. The interface shall display a detailed view panel containing information about the selected mod and its dependency relationships.

.D. Usability and Responsiveness
. The interface shall implement responsive behavior to ensure usability across different screen sizes.
. The system shall provide clear feedback messages when dependency data cannot be loaded or is incomplete.
. The layout and labeling shall remain consistent to ensure ease of understanding for non-technical users.

=== 2.9 Operational Requirements

This section defines measurable criteria based on the Machine Requirements stated in Section 2.3.4.
While Section 2.3.4 explains how the system is expected to behave, this section specifies concrete limits and thresholds used to evaluate performance, reliability, and scalability during testing.

==== Performance Requirements

* The system must respond to a mod metadata lookup request (via external API such as Modrinth) within 3 seconds under normal load (≤ 20 simultaneous users performing lookup operations).
* The system must update and re-render the dependency graph within 2 seconds after a mod is added, removed, or modified, for modpacks containing up to 150 mods.
* The system must download and append a mod file (≤ 20MB) to the modpack archive within 10 seconds, excluding external network delays beyond the system's control.

==== Concurrency Requirements

* The system must support at least 20 simultaneous active users, each performing metadata lookups and graph updates, without service interruption.
* If the number of simultaneous active users exceeds 20, the system must continue operating and may queue additional requests with a maximum delay of 10 seconds.
* The system must not crash when handling concurrent download and graph update operations.

==== Reliability Requirements

* The system must maintain 95% uptime during scheduled operational hours.
* If an external API (e.g., Modrinth) fails or becomes unreachable, the system must:
* Return a clear error message to the user within *5 seconds, and
** Allow the user to retry the operation.
* The failure of an external API must not cause the entire application to terminate.

==== Integrity Requirements

* The system must validate that a downloaded mod file is successfully retrieved before appending it to the modpack archive.
* The system must ensure that the modpack archive remains structurally valid after file modifications.
* The system must prevent duplicate mod files with identical identifiers from being appended without user confirmation.

==== Degradation & Limits

* Under heavy load, the system may:
* Increase response time up to *8 seconds for metadata lookups, and
** Queue download operations.
* The system must not terminate unexpectedly under heavy load conditions.
* Criteria for long-term scalability beyond 30 simultaneous users remain to be researched and defined.

The backend system must meet measurable and realistic machine requirements to ensure efficient dependency graph construction, scalability, and reliability when processing Minecraft mod metadata.

Graph Processing Performance: The system must generate a dependency graph for modpacks containing between 30 and 100 mods under typical conditions in less than 5 seconds.
For larger modpacks containing up to 200 mods, the system must generate the dependency graph in less than 10 seconds.
For extreme cases containing between 200 and 500 mods, the system may require between 30 seconds and 2 minutes depending on graph complexity but must complete the process in a stable and predictable manner without system failure.

Concurrent Requests: The backend must be designed to support multiple concurrent users performing dependency analysis and graph generation.
Since the expected number of concurrent users depends on the final scope of the application, the system must maintain stable performance and predictable response times under moderate and peak usage scenarios.

External Metadata Handling: The system must retrieve dependency and incompatibility data from external platforms such as CurseForge and Modrinth.
The backend must handle rate limits, temporary service failures, incomplete responses, and data inconsistencies.
When external services are unavailable, the system must use cached or previously processed data when possible and provide meaningful feedback to the user.

Reliability and Availability: The system must maintain high availability during active usage.
Automatic recovery mechanisms must handle network failures, API interruptions, and temporary service outages.
The backend must prevent corruption of dependency and modpack data and ensure consistent graph construction results.

Scalability: The architecture must support horizontal scaling to accommodate future increases in modpack size, graph complexity, and user demand.
The backend must be modular to allow improvements and extensions without redesigning core components.

Resource Usage: Memory and CPU usage must remain within acceptable limits during graph construction and metadata processing.
Monitoring and logging must be implemented to detect performance bottlenecks and abnormal resource consumption.

Stability and Graceful Degradation: Under overload conditions or limited resources, the system must degrade gracefully by prioritizing essential operations, applying request throttling, and avoiding system crashes.

Data Integrity and Validation: Dependency data must be validated and normalized before graph construction.
The system must ensure accurate representation of required, optional, and incompatible dependencies, as well as version constraints.

=== 2.10 Software Architecture Design

The system follows a layered client - server architecture composed of four main components:

* Frontend (Presentation Layer): Handles mod upload, user interaction, search functionality, and visualization of the dependency graph.
  It renders mods as nodes and dependencies as directed edges, and provides visual indicators for missing, satisfied, or incompatible dependencies.
* Backend API Layer: Receives uploaded metadata, validates input, coordinates processing, and returns structured JSON results to the frontend.
  It also manages request handling, logging, and retry mechanisms for external API calls.
* Dependency Resolution Engine (Core Layer): Parses mod metadata, normalizes dependency information, resolves required and optional dependencies, detects incompatibilities and circular dependencies, validates version constraints, expands transitive dependencies, and constructs the internal dependency graph model.
* Data & Integration Layer: Communicates with external mod repositories such as Modrinth and CurseForge.
  It handles metadata retrieval, caching of previously accessed data, and graceful error handling when external services are unavailable.

== 3. Analytical

=== 3.1 Concept Formation

The Team A domain sketch illustrates the operation of the Mod Dependency Analyzer tool.

* Based on these observations:
** Mod: an artifact software uploaded by the user.
** Dependency: relationship that indicates that one mod requires another.
** DTO: abstraction used to carry mod and dependency.
** Dependency Graph: structured network formed by interconnected dependency relationships.
* Grouping decisions: libraries needed and mods needed for a mod to work are grouped as Dependency because both are prerequisites.
* Conflicts: dependency refers to both libraries and mods; graph refers to a data structure and not a visual representation.

The Team B analysis focuses on situations where declared dependencies must be located and associated in order to complete a mod configuration.

* Required dependencies are often not included in the initial modpack configuration.
* Missing components must be identified by consulting external mod repositories.
* Resolving dependency issues involves not only recognizing relationships between mods, but also locating the components that satisfy those relationships.
* Mod repositories function as reference environments that describe and provide the required mods.

From these observations, dependency resolution is understood as a domain process connecting declared relationships with available components.

* A dependency implies that the required mod exists in the ecosystem and must be discoverable.
* Completing a configuration involves identifying and associating those components with the current modpack.
* External sources are treated as part of the environment where dependencies are satisfied.

=== 3.2 Validation

The team validates the requirements and domain understanding through structured scenario-based walkthroughs.
These walkthroughs simulate realistic modpack configurations and are discussed collectively to identify ambiguities, missing edge cases, or incorrect assumptions about domain concepts such as Mod, Dependency, Incompatibility, and Modpack.

The goal of validation is not to obtain approval, but to ensure that the system-to-be correctly reflects the domain relationships and user needs.

==== Scenario 1: Missing Mandatory Dependency

Context: A user uploads a modpack containing Mod A, which declares a mandatory dependency on Mod B.
Mod B is not included in the uploaded modpack.

Walkthrough Steps:

. The system parses metadata of all uploaded mods.
. The declared dependencies of Mod A are extracted.
. The system checks whether Mod B exists in the modpack.
. The dependency graph is generated.
. Missing dependency is visually highlighted.

Validation Outcome: During walkthrough discussion, the team clarified the distinction between mandatory and optional dependencies.
The requirement was refined to explicitly differentiate these cases and ensure that only mandatory dependencies trigger critical warnings.

==== Scenario 2: Circular Dependency Case

Context: Mod A depends on Mod B, and Mod B depends on Mod A.

Walkthrough Steps:

. Dependencies are parsed.
. The graph is constructed.
. The system analyzes graph structure for cycles.

Validation Outcome: A new requirement was added to explicitly detect circular dependencies and notify users when a cycle exists.
The concept of "graph as structural model" was distinguished from "graph as visual representation."

=== 3.3 Verification

Verification ensures that the Minecraft Mod Dependency Visualizer functions as intended and satisfies the specified requirements.
The system will be verified through functional testing and user validation.

* Unit Testing: Individual components such as metadata extraction and dependency parsing will be tested independently to ensure they produce correct and consistent results.
* Functional Testing: The system will be tested to confirm that a user can upload a mod file, generate a dependency graph, and receive accurate compatibility feedback.
* User Validation: A small group of users will test the application to verify usability, clarity of the visualization, and correctness of the compatibility results.
  Feedback will be used to improve system behavior and interface design.
* Performance Testing: The system will be evaluated to ensure it processes mod files within the required response time and maintains stability under multiple usage scenarios.

Verification will be considered successful when all functional requirements are met and no critical defects are present.