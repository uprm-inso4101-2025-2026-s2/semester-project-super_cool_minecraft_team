University of Puerto Rico at Mayagüez
Department of Computer Science and Engineering
ICOM4009 | INSO4101 | Introduction to Software Engineering



Project Proposal
Minecraft Dependency Visualizer



1. Informative
1.1 Name, Place and Date
    Name: Minecraft Dependency Visualizer
    Place: University of Puerto Rico at Mayagüez
    Date: February 2026

1.2 Team Members
1.2.1 Managers:
    - John Doe
1.2.2 Team Leaders:
    - Team A:
        - John Doe
    - Team B:
        - Jane Smith
    - Team C:
        - Alice Johnson

1.2.3 Team Members:
    - Team A:
        - John Doe
        - Mark Brown
    - Team B:
        - Jane Smith
        - Emily Davis
    - Team C:
        - Alice Johnson
        - Michael Wilson

1.3 Current Situation
    Minecraft mods rely on other mods, loaders, libraries and specific minecraft versions which would be the mod dependedncies. 
    If these dependencies aren't met the game will crash or won't launch. This leads to user frustration and wasting their time. These dependencies arent very 
    easy to acces, and while it would be better to have them in the main dowloader page they are usually seen as plain text in metadata or in dedicated wikis which
    people who aren't welled versed wont find.

== 1.4. Needs and Ideas

    We identify that many Minecraft mods rely on other mods, libraries, specific loaders, and specific Minecraft versions in order to function correctly. When dependencies are missing, incompatible, or incorrectly ordered, the game often fails to launch or crashes during runtime. 

    There is a significant lack of accessibility in dependency documentation. Currently, users are forced to parse technical plain text, which is particularly exclusionary for younger audiences who make up a large portion of the Minecraft community. Furthermore, most mods do not display dependencies or incompatibilities clearly on their main mod pages. We want to change this experience for users to save them from the frustration that leads them to abandon the idea of using Minecraft mods because they do not understand the underlying technical issues.

    There is, therefore, a need to develop a mod dependency visualization platform that represents mods as nodes and dependencies as directed connections. The platform will allow users to select a mod and view which mods depend on it and why it is required. The team will develop a comprehensive web-based platform designed to transform the way Minecraft players interact with mod configurations. The approach is to move away from text-heavy logs and provide a Dynamic Dependency Graph. This will make conflict detection visual and easy to manage for all users.

1.5	Concepts
    - Concept 1: Mod (Entity)
        A packaged software extension for Minecraft that adds or changes gameplay functionality and declares metadata such as version, supported Minecraft and Mod Loader versions, and dependency constraints.
    - Concept 2: Modpack (Entity)
        A selected set of Mods intended to run together under a specific Minecraft version and Mod Loader, whose correctness depends on satisfying all declared constraints.
    - Concept 3: Dependency (Relation)
        A directed requirement from one Mod to another Mod or library indicating that the target must be present and satisfy any stated Version Constraint for the source Mod to operate correctly within a Modpack.
    - Concept 4: Incompatibility (Relation)
        A declared constraint between two Mods or specific versions stating they must not coexist in the same Modpack due to functional or version conflicts.
    - Concept 5: Version Constraint (Attribute)
       A rule attached to a Dependency or Incompatibility declaration that specifies which versions of a target Mod are acceptable.
    - Concept 6: Dependency Resolution (Behavior)
        The process of determining whether a Modpack satisfies all required Dependencies, including transitive ones, and does not violate declared Incompatibilities or Version Constraints.

1.6 Scope and Span
    The completed project will be a web-app that can be given an input of Fabric or Forge mod files or a medium sized modpack for the game Minecraft Java Edition to view what the user can safely update and/or remove from it without having to go through trial and error of removing and adding them manually to see what doesn't crash the game or prevent you from joining a modded multiplayer server.

    It will visually demonstrate to the user what dependencies are installed or missing, as well as if they are required or supplementary. It will also show how many mods depend on each dependency and if they are safe to remove or not. 

    It will be able to separate Client-side mods from Host-side and Client-Host-Sided mods so you don't accidentally remove something necessary for multiplayer.

    Detect known incompatibilities and point them out to the user, and identify known compatible versions when metadata exists that particular mods may have with other mods.

    If a mod has an update, or a missing required/supplementary dependency it will give the user a CurseForge or Modrinth link so they can choose to install. 

    This web-app will not install/modify the mods, or launch the game with mods, only point out to the user what they can do with their current mod list in terms of updating/removing mods.

    Access to a Chromium or Firefox based browser on a Computer with an Internet connection will be required.


1.6.2 Project Span
    This section outlines the specific boundaries, key activities, and focus areas of the project, translating the high-level goals from
    the project scope into a concrete and actionable plan. It defines what the project will and will not undertake to ensure its
    objectives are realistic and achievable within the constraints for a cohort of 43 students.

1.6.2.1 Inclusions
    The project will focus on the design, development, and evaluation of a web-based proof-of-concept platform for visualizing
        -Minecraft mod dependencies. The core activities included in the project span:
        -Platform Development: Create an interactive, browser-based prototype that visualizes mods as nodes and their
        dependencies as directed edges in a graph data structure. The platform will be designed to support a curated dataset of
        mods, rather than attempting to index the entire CurseForge and Modrinth repositories.
        -Metadata Parsing and Normalization: Develop scripts to programmatically parse dependency metadata from a preselected set of mods sourced from CurseForge and Modrinth. This includes identifying required dependencies, optional
        dependencies, and incompatible mod versions. The project will handle all mod metadata in accordance with ethical data
        handling principles, ensuring that any data acquisition, storage, and processing respects the terms of use and privacy
        expectations established by the source repositories. The data will then be normalized into a unified internal schema to
        manage inconsistencies between the two source platforms.
        -Visual Highlighting of Critical Information: Implement visual cues within the graph interface to draw user attention to key
        issues. This will include distinct highlighting for missing dependencies, version incompatibilities, and optional relationships.
        -Decision-Support Features: Enable users to interact with the graph and access relevant information. Upon selecting a
        specific mod node, the platform will display:
        Its direct and transitive dependents (i.e., which other mods rely on it).
        A plain-language explanation of its dependency requirements (e.g., "Required for game launch on the client-side").
        A simulation of the potential impact, highlighting which other mods would be affected if the selected mod were
        removed or updated.
        -Evaluation with Sample Modpacks: Conduct a formal evaluation of the prototype's effectiveness using sample modpacks.

1.6.2.2 Exclusions
    To maintain a realistic scope and focus on the core problem of visualization and understanding, the following activities are
    explicitly excluded from the project span:
        -Automated Installation or Management: The platform will function solely as a decision-support tool. It will not download,
        install, update, remove, or modify a user's Minecraft instance.
        -Visual Highlighting of Critical Information: Implement visual cues within the graph interface to draw user attention to key
        launcher, MultiMC, Prism Launcher).
        -Exhaustive Mod Indexing: The project will not attempt to index or visualize all mods available on CurseForge and Modrinth.
        The focus will be on a curated, representative dataset sufficient to demonstrate the platform's functionality and core
        features.
        -Generalization to Other Games: Potential for future generalization is acknowledged (Section 6), but the development and
        testing of the prototype will be strictly confined to the Minecraft modding ecosystem.

        -Addressing Runtime Errors: The project will not build a system that diagnoses live game crashes or reads Minecraft log
        files. Its purpose is preventative and analytical, focusing on understanding dependencies before launching the game.
        -Commercial Deployment: The final deliverable will be a functional prototype for academic evaluation, not a productionready, publicly hosted service.

1.6.2.3 Key Focus Areas and Methodology
    The project will be executed using an agile-inspired methodology suitable for a student team. Work will be organized into
    iterative sprints, each focusing on a key deliverable. The primary focus areas are:
        -Data Acquisition & Modeling: Researching and implementing the parsing of metadata from CurseForge/Modrinth APIs and
        designing the internal graph data structure.
        -Graph Visualization Engine: Selecting and implementing a suitable JavaScript library (e.g., D3.js, vis.js, Cytoscape.js) to
        render the interactive dependency graph.
        -User Interface & Interaction: Designing and building the user interface components for displaying mod information, search,
        and selection, ensuring clarity and ease of use.
        -Evaluation & Analysis: Defining success metrics, designing user test cases, conducting the evaluation, and analyzing the
        results to determine the project's success against the criteria outlined in Section 5.

1.6.2.4 Timeline
    The project milestones and key dates are as follows:
        - Project A3 submissions: January 27–30
        - Project selection: February 2
        - First milestone ends: February 27
        - Milestone 1 presentation: March 2
        - Second milestone ends: April 3
        - Milestone 2 presentation: April 6
        - Final milestone ends: May 8
        - Final milestone presentation: May 11
These dates define the structured time frame within which all planning, development, evaluation, and reporting activities will be
conducted. All deliverables and presentations will be completed in accordance with this timeline to ensure timely progress and
academic review.

1.7 Synopsis
Minecraft modding has become a common way for players to expand and personalize the game experience, but it also introduces a recurring challenge: many mods rely on other mods, libraries, specific loaders, and specific Minecraft versions in order to function correctly. When these dependencies are missing, incompatible, or incorrectly ordered, Minecraft may fail to launch or crash during runtime. This situation is often made worse by the lack of accessibility in dependency documentation, since users are frequently forced to interpret technical plain text and logs, and many mods do not clearly display their dependencies or incompatibilities on their main pages. As a result, many users become frustrated and abandon the idea of using mods because they cannot easily understand what is going wrong.

To help diminish the effects of this problem, the team proposes the Minecraft Dependency Visualizer, a web-based platform intended to make dependency management more understandable and approachable. The platform will represent mods as nodes and dependencies as directed connections, forming a Dynamic Dependency Graph that users can explore. Users will be able to select a mod and view which mods depend on it, as well as why it is required within a configuration. In addition, the platform will support identifying and signaling conflicts through incompatibility information, helping users recognize when certain mods cannot coexist in the same mod configuration.

At the core of the platform is the ability to analyze a user’s selected mod collection (modpack) and validate it through dependency resolution and conflict analysis. Dependencies will be classified into exactly one type—required, optional, or incompatible—and the platform will represent dependencies transitively, ensuring that dependencies of dependencies are also included. By shifting the experience away from text-heavy troubleshooting and toward a clear visual representation, the Minecraft Dependency Visualizer aims to reduce confusion, improve accessibility for all users, and make modpack setup and maintenance significantly easier.

1.8 Assumptions and Dependencies

    - Assumption A: Reliable access to Minecraft mod metadata sources is available during development.
    
    Dependency: The project depends on these sources to design and test dependency parsing and resolution logic.

    Risk: If metadata access is disrupted or formats change, development may be delayed while adapting the tool.

    - Assumption B: The project’s requirements and scope will stay consistent during the development phase.

    Dependency: Design choices and implementation plans depend on stable requirements to minimize the need for rework.

    Risk: Major changes may affect the schedule and necessitate adjustments to key components.

    - Assumption C: The necessary development tools, environments, and test data are accessible and correctly set up.

    Dependency: The team depends on these resources to develop and test the dependency tool.

    Risk: If these resources are unavailable or improperly configured, progress may be delayed and errors could be introduced.

1.9 Implicit and Derived Goals
    - Goal 1: Simplify and automate the management of Minecraft mods and libraries to ensure all dependencies are correctly installed and compatible, reducing errors and manual configuration for users.

    - Goal 2: Provide a reliable system for detecting version conflicts and missing dependencies, enabling mod developers and players to maintain stable modpacks without technical troubleshooting.

    - Goal 3: Offer optional features such as dependency visualization and compatibility suggestions to enhance user experience and improve modpack maintenance efficiency.

2. Descriptive

2.1 Rough Sketch of the Domain
    Many users frequently confuse the Fabric Loader with the Fabric API, leading to situations like a case where a player  complained that their game 
    wouldn't start because it was missing the API, despite having already installed the loader. This confusion is tied to a general frustration with "Library mods,"
    where an average player downloads a "main" mod but ignores the fact that it depends on three or four others, which in turn require specific matching versions of the API. 
    For example, a player tried to move his world to a later Minecraft version, but the game crashed immediately because his existing mod list didn't meet the new version's 
    dependencies; he spent hours trying to find the right files before eventually giving up. Furthermore,there is a segment of the audience that is interested in trying mods 
    for the first time but lacks the technical knowledge to obtain them. These users find that existing guides are not very explicit and assume they already know how to handle 
    file directories or Java versions, leading many potential players to simply stop trying altogether to avoid the complexity and frustration of the installation process.

2.2 Narrative
    Within the mod ecosystem of Minecraft, users construct gameplay configurations by combining independently developed modifications, each of which declares structural constraints through metadata. A Mod specifies its identity, supported versions, required dependencies, optional dependencies, and declared incompatibilities. When multiple Mods are grouped into a Modpack, they form a configuration whose validity depends on the collective satisfaction of all declared requirements and constraints. Adding or removing a Mod triggers domain behaviors such as dependency expansion (through transitive requirements), compatibility evaluation, and conflict detection. A configuration is considered structurally valid only if every required dependency is present in a compatible version and no declared incompatibilities exist among included Mods. These relationships can be abstracted as a dependency network in which Mods participate in directed requirement relations and constraint relations.

2.3 Requirements
## Team C – Frontend (Mod Uploading) Requirements

- The system shall provide a user interface that allows the user to upload a modpack file or a supported mods folder.

- The system shall validate that the uploaded file is not empty and is in a supported format before processing.

- The system shall display real-time feedback during upload (idle, uploading, processing, success, error).

- The system shall prevent submission if validation fails and display a clear, user-friendly error message.

- The system shall allow the user to retry the upload process without restarting the application.

- The UI shall provide clear instructions describing how users can compress their modpack into a .zip file before uploading.
# 2.3.2 — Personas


(Joyson addition)


Recommended Algorithms for the project's sorting

Lists (ArrayList) used for:

Storing installed mods
Storing dependencies
Storing search results

HashSet used for:

Quickly checking if a dependency is already installed and avoid duplicate entries

HashMap used for:

Map Mod → List of Dependencies
Map Mod → Status

Sorting

Bubble Sort

For small lists of download links

Selection Sort

To sort mods by status (Missing, Resolved, Incompatible, etc.).

Searching Techniques
Linear Search

To find a mod in a list.

Simple String Matching (equals / contains / not equal to [to avoid erroneous links])

To match mod names from web results.

# 2.3.4 - Interface requirements

- The subsystem must be capable of receiving dependency metadata from the Mod Uploading subsystem, including mod identifiers, version information, and declared dependencies.
- Queries to the Modrinth API (or similar repositories) should allow the system to locate required mods using dependency identifiers.
- Download URLs for compatible dependency versions must be retrieved and made available for installation.
- Structured results of the dependency resolution process are returned to the Visualization subsystem, including resolved dependencies, version matches, and any unresolved items.
- Notifications are provided whenever a required dependency cannot be resolved, ensuring the system or user is aware of the issue.
- Failed API requests should trigger automatic retries up to a configurable limit to maintain reliability.
- All interactions with external APIs are logged for debugging, verification, and auditing purposes.

# 2.3.5 – Machine Requirements

Performance:
- The subsystem shall process dependency resolution requests efficiently, ensuring reasonable response times for typical user workloads.
- The system shall handle multiple simultaneous requests without significant delays or system instability.
- Retrieval of download links for dependencies shall be performed in a timely manner to support smooth operation of the user workflow.

Reliability:
- The subsystem shall maintain continuous operation during normal usage, with minimal downtime.
- External API failures shall be handled gracefully, ensuring that partial failures do not crash the system or corrupt data.
- Errors and exceptions shall be logged to support debugging and verification.

Resource and Stability:
- The subsystem shall operate within reasonable memory and CPU usage to avoid affecting other system components.

Scalability: 
- The system shall be designed to accommodate growth in mod volume and user activity.


---  
    - Requirement 1: Fetching dependencies of mods, this could be created with fabric API for maximum efficency and modularity.
    - Requirement 2: Fetch the "breaks" in the mods for comparing with dependencies in the modpack and indicate if some mods are incompatible, coul use fabric API too.
    - Requirement 3: Open the mod packs and read the content for the fetch functions. Needs to read each mod individually to check for the "breaks".
    - Requirement 4: Pass the data to the other layers of the project to be used on the graph and display.
    - Requirement 5: Storing the dependencies needed and the mods passed by the user.
    - Requirement 6: Merge the dependencies and "breaks" for comparate and identify the incompatibilities.
    - Requirement 7: The platform must associate each dependency with exactly one dependency type: required, optional, or incompatible.
    - Requirement 8: The platform must represent dependencies transitively, such that dependencies of dependencies are included.


2.4 Terminology

This section defines the core terms that will be used throughout the project. These definitions apply to both the backend dependency logic and the frontend graph interface.

Goal -> Keep the language consistent across documentation and communication.

Each term includes:

->Classification (Entity, Relation, Attribute, Event, Behavior)
->Phase Introduced (Domain = Minecraft ecosystem concept, System = project-specific concept)
->Definition (Implementation-independent)

##################################################################
Dependency Resolution / Mod Graph Terminology
##################################################################

1. Mod (Modification)

Classification: Entity
Phase Introduced: Domain
Definition: A mod (modification) is a packaged software extension that alters or adds functionality to Minecraft. A mod may introduce new content, mechanics, or systems and may declare dependencies or incompatibilities with other mods.

2. Dependency

Classification: Relation
Phase Introduced: Domain
Definition: A dependency is a directed relationship in which one mod requires another mod in order to function correctly. If the required mod is missing or does not satisfy the stated version constraint, the dependent mod cannot operate as intended.

3. Optional Dependency

Classification: Relation
Phase Introduced: Domain
Definition: A relationship where a mod can integrate with another mod if it is present, but does not require it for core functionality.

4. Version

Classification: Attribute
Phase Introduced: Domain
Definition: A structured identifier assigned to a specific release of a mod. Versions are used to distinguish releases and evaluate compatibility between mods.

5. Version Constraint

Classification: Attribute
Phase Introduced: Domain
Definition: A rule that specifies which versions of a mod are acceptable within a dependency relationship. A version constraint defines a valid range or condition that must be satisfied.

6. Minecraft Version

Classification: Entity
Phase Introduced: Domain
Definition: A specific release of Minecraft and its updates. It defines the base environment and APIs that mods and mod loader target. Important for the compatibility constraint in the dependency graph.

7. Mod Loader

Classification: Entity
Phase Introduced: Domain
Definition: A runtime framework responsible for loading and managing mods within Minecraft. A mod loader establishes compatibility rules and governs how mods are initialized and executed.

8. Fabric

Classification: Entity
Phase Introduced: Domain
Definition: The mod loader to be used for this project. It provides the framework for loading mods.

9. Mod Instance

Classification: Entity
Phase Introduced: System
Definition: A specific occurrence of a mod identified by name and version within the system. A mod instance represents a concrete node in the dependency graph.

10. Mod pack

Classification: Entity
Phase Introduced: Domain
Definition: A collection of mod instances, their version, and associated configuration files.

11. Dependency Graph

Classification: Entity
Phase Introduced: System
Definition: A directed graph structure that represents mod instances as nodes and dependency relationships as edges. The graph models how mods depend on one another.

12. Node

Classification: Entity
Phase Introduced: System
Definition: A logical and visual representation of a mod instance within the dependency graph.

13. Edge

Classification: Relation
Phase Introduced: System
Definition: A directed connection between two nodes that represents a dependency relationship.

14. Resolution

Classification: Behavior
Phase Introduced: System
Definition: The process of evaluating whether all declared dependencies within a given mod set are satisfied according to version constraints and compatibility rules.

15. Conflict

Classification: Event
Phase Introduced: System
Definition: A condition that occurs when dependency requirements or version constraints cannot be satisfied simultaneously. A conflict prevents successful resolution of the mod set.

16. Compatibility

Classification: Attribute
Phase Introduced: Domain
Definition: The state in which two or more mods, versions, or loaders can operate together without violating declared dependencies or constraints.

17. Installation State

Classification: Attribute
Phase Introduced: System
Definition: The current status of a mod instance within the managed environment, such as installed, missing, unresolved, or conflicting.

18. Transitive Dependency

Classification: Relation
Phase Introduced: System
Definition: A dependency that arises indirectly through a chain of other dependencies. If Mod A depends on Mod B, and Mod B depends on Mod C, then Mod A has a transitive dependency on Mod C.

19. Profile

Classification: Entity
Phase Introduced: System
Definition: A named container that stores a user’s mod instances and their installation statuses.

##################################################################
Mod Uploading Terminology
##################################################################

Term: UploadSession
Classification: Entity
Phase: Domain
Definition: The complete process of uploading one or more mod files, from initial selection to final confirmation.

Term: ModFile
Classification: Entity
Phase: Domain
Definition: The actual game modification file being uploaded, typically in .jar, .zip, or .rar format.

Term: UploadQueue
Classification: Entity
Phase: System
Definition: A visual list component displaying all files selected for upload and their current processing status.

Term: UploadStatus
Classification: Attribute
Phase: System
Definition: The current state of an upload (idle, uploading, paused, completed, failed, or cancelled).

Term: FilePicker
Classification: Entity
Phase: System
Definition: A UI component that opens the system dialog for users to browse and select files from their computer.

Term: DragAndDropZone
Classification: Entity
Phase: System
Definition: A designated UI area where users can drag files directly from their desktop to initiate upload.

Term: FileSelected
Classification: Event
Phase: Domain
Definition: User action of choosing a file through the file picker dialog.

Term: FileDropped
Classification: Event
Phase: Domain
Definition: User action of dragging and releasing a file into the drag and drop zone.

Term: UploadStarted
Classification: Event
Phase: Domain
Definition: User action of initiating the upload process after file selection.

Term: UploadCancelled
Classification: Event
Phase: Domain
Definition: User action that aborts an ongoing file upload.

Term: UploadPaused
Classification: Event
Phase: Domain
Definition: User action that temporarily stops an active upload.

Term: UploadResumed
Classification: Event
Phase: Domain
Definition: User action that continues a paused upload.

Term: RetryUpload
Classification: Event
Phase: Domain
Definition: User action that attempts to upload a previously failed file again.

Term: UploadProgress
Classification: Attribute
Phase: System
Definition: Numerical value (0-100%) indicating how much of a file has been successfully transferred.

Term: ProgressIndicator
Classification: Entity
Phase: System
Definition: Visual element showing upload completion percentage, can be a progress bar, spinner, or percentage text.

Term: FilePreview
Classification: Entity
Phase: System
Definition: Thumbnail, icon, or filename display representing the uploaded file.

Term: ValidationFeedback
Classification: Behavior
Phase: System
Definition: Visual messages displayed to users indicating if a selected file meets requirements.

Term: ValidationError
Classification: Attribute
Phase: System
Definition: A specific message indicating why a file was rejected (wrong format, too large, etc.).

Term: FileSizeWarning
Classification: Attribute
Phase: System
Definition: Notification that the selected file exceeds recommended size limits.

Term: UploadComplete
Classification: Event
Phase: Domain
Definition: Notification that all files have been successfully transferred to the server.

Term: MetadataForm
Classification: Entity
Phase: System
Definition: UI form where users can add additional information about the uploaded mod.

Term: CancelButton
Classification: Entity
Phase: System
Definition: UI element that allows users to abort an ongoing upload.

Term: TimeRemaining
Classification: Attribute
Phase: System
Definition: Estimated time display showing how long until upload completes.

Term: UploadSpeed
Classification: Attribute
Phase: System
Definition: Real-time display of data transfer rate during upload.

2.5 Domain Entities
    - Mod:
        Represents a Minecraft modification that extends the base game and may declare dependencies or incompatibilities.
        
    - Dependency:
        Represents a directed requirement where one Mod depends on another Mod, possibly constrained by version.

    - Incompatibility:
        Represents a conflict condition in which two Mods cannot coexist in the same Modpack.

    - Modpack:
        Represents a collection of Mods intended to function together within a Minecraft instance

    - Dependency Graph:
        Represents the conceptual structure of Mods and their dependency relationships.

    - User:
        Represents an individual who analyzes Modpacks and their dependencies.

		- Dependency Resolution:
		    Represents the process of identifying and retrieving required Mods for a Modpack.

		- Mod Source:
		    Represents an external repository from which Mods and their versions can be obtained.

		- Download Task:
		    Represents the retrieval of a specific Mod version required to satisfy a Dependency.

		- Retrieved Mod:
		    Represents a Mod successfully obtained to fulfill a Dependency requirement.

		- Resolution Result:
		    Represents the outcome of dependency analysis, indicating satisfied, missing, or conflicting Mods.
        
	2.6 Domain Functions
		
		A. Resolve Dependencies
		   a. Collect dependency information declared by each Mod in a Modpack.
		   b. Determine whether required dependencies are satisfied.
		   c. Produce a Resolution Result summarizing satisfied, missing, and conflicting items.
		
		B. Find Missing Dependencies
		   a. Compare required dependencies against the Mods included in the Modpack.
		   b. List missing required dependencies in the Resolution Result.
		
		C. Detect Conflicts / Incompatibilities
		   a. Check incompatibility rules when available.
		   b. Identify mods that cannot coexist and record conflicts in the Resolution Result.
		
		D. Check Version Rules
		   a. Verify that mod versions satisfy dependency version constraints.
		   b. Record version mismatches in the Resolution Result.
		
		E. Locate Mod Sources
		   a. Identify possible Mod Sources where missing dependencies can be found.
		   b. Collect candidate references/versions from those sources.
		
		F. Create and Execute a Download Task
		   a. Create a Download Task for a selected candidate reference.
		   b. Retrieve the dependency as a Retrieved Mod (conceptually) for inclusion in the resolved configuration.
		
		G. Build and Export the Dependency Graph
		   a. Add Mod nodes to the Dependency Graph.
		   b. Add Dependency edges between Mods based on declared relationships.
		   c. Avoid duplicate nodes/edges when building the graph.
		   d. Export the Dependency Graph into a JSON representation for visualization.

2.7 Domain Events

    - Event 1: Modpack Provided for Analysis
      Meaning: A modpack becomes available for dependency analysis.
      After: Its metadata can be examined and its declared dependencies can be identified.
      State Change: The modpack transitions from “not analyzed” to “analysis in progress.”

    - Event 2: Dependencies Identified
      Meaning:All declared dependencies of included mods have been extracted from metadata.
      After:Each dependency exists in normalized form and is classified as required, optional, incompatible, or version-constrained.
      State Change: Dependency data transitions from “raw metadata” to “identified and classified.”

    - Event 3: Dependency Graph Exists
      Meaning:A dependency graph representing all declared relationships among mods has been constructed.
      After:All mods appear as nodes and their declared relationships exist as directed edges.
      State Change: The modpack transitions to “dependency graph constructed.”

    - Event 4: Missing Dependency Exists 
      Meaning: A required dependency declared by a mod is not present in the modpack.
      After: The configuration is incomplete.
      State Change: The modpack transitions to “invalid missing required dependency.”

    - Event 5: Incompatibility Exists
      Meaning: Two or more mods declare mutual incompatibility.
      After: The configuration contains conflicting components.
      State Change: The modpack transitions to “invalid incompatibility conflict.”

    - Event 6: Circular Dependency Exists
      Meaning: A cycle exists in the dependency relationships among mods.
      After: The dependency structure cannot be resolved hierarchically.
      State Change:The modpack transitions to “invalid circular dependency.”

    - Event 7: Version Constraint Violation Exists
      Meaning: A mod version does not satisfy the version constraints declared by dependent mods.
      After: The configuration violates declared version requirements.
      State Change: The modpack transitions to “invalid version constraint violation.”

    - Event 8: Transitive Dependencies Expanded
      Meaning: Indirect dependencies (dependencies of dependencies) have been incorporated into the dependency structure.
      After: The complete dependency chain exists.
      State Change: The modpack transitions from “direct dependencies only” to “complete dependency closure.”

    - Event 9: Dependency Resolution Completed
      Meaning:The process of resolving all declared dependencies has finished.
      After: It is determined whether all required dependencies are satisfied.
      State Change: The modpack transitions from “resolution in progress” to either “resolved successfully” or “resolution failed.”

    - Event 10: Dependency Has Become Unsatisfied
    Meaning: A previously satisfied dependency becomes invalid due to mod removal, version change, or constraint violation.
    After: The configuration no longer satisfies all declared requirements.
    State Change: The modpack transitions from “dependency satisfied” to “dependency unsatisfied.”
      
    - Event 11: Modpack Configuration Validated
    Meaning: All dependency, incompatibility, circularity, and version checks have completed successfully.
    After: The modpack is structurally valid.
    State Change: The modpack transitions to “valid configuration.”
      
    

    2.8 Interface Requirements
    - Allow users to upload mod files or submit mod metadata for processing.
    - Validate uploaded metadata and report errors for missing or malformed entries.
    - Provide client-side feedback and visual indicators during file upload.
    - Implement responsive UI behavior to ensure usability across screen sizes.
    - Allow users to visually explore mod dependency relationships through an interactive dependency graph.
    - Allow users to select a mod and view its required, optional, and incompatible dependencies.
    - Provide a search interface to locate mods by name or identifier.
    - Display clear visual indicators to distinguish between satisfied, missing, and incompatible dependencies.
    - Provide a detailed view panel showing information about the selected mod and its dependency relationships.
    - Allow users to navigate between related mods directly from the dependency visualization.
    - Provide clear feedback messages when dependency data cannot be loaded or is incomplete.
    - Maintain consistent layout and labeling to ensure ease of understanding for non-technical users.


2.9 Machine Requirements
## Performance Requirements

- The system must respond to a mod metadata lookup request (via external API such as Modrinth) within **3 seconds** under normal load (≤ 20 simultaneous users performing lookup operations).

- The system must update and re-render the dependency graph within **2 seconds** after a mod is added, removed, or modified, for modpacks containing up to **150 mods**.

- The system must download and append a mod file (≤ 20MB) to the modpack archive within **10 seconds**, excluding external network delays beyond the system’s control.

---

## Concurrency Requirements

- The system must support at least **20 simultaneous active users**, each performing metadata lookups and graph updates, without service interruption.

- If the number of simultaneous active users exceeds 20, the system must continue operating and may queue additional requests with a maximum delay of **10 seconds**.

- The system must not crash when handling concurrent download and graph update operations.

---

## Reliability Requirements

- The system must maintain **95% uptime** during scheduled operational hours.

- If an external API (e.g., Modrinth) fails or becomes unreachable, the system must:
  - Return a clear error message to the user within **5 seconds**, and  
  - Allow the user to retry the operation.

- The failure of an external API must not cause the entire application to terminate.

---

## Integrity Requirements

- The system must validate that a downloaded mod file is successfully retrieved before appending it to the modpack archive.

- The system must ensure that the modpack archive remains structurally valid after file modifications.

- The system must prevent duplicate mod files with identical identifiers from being appended without user confirmation.

---

## Degradation & Limits

- Under heavy load, the system may:
  - Increase response time up to **8 seconds** for metadata lookups, and  
  - Queue download operations.

- The system must not terminate unexpectedly under heavy load conditions.

- Criteria for long-term scalability beyond 30 simultaneous users remain to be researched and defined.

---
    The backend system must meet measurable and realistic machine requirements to ensure efficient dependency graph construction, scalability, and reliability when processing Minecraft mod metadata.

    Graph Processing Performance:
    The system must generate a dependency graph for modpacks containing between 30 and 100 mods under typical conditions in less than 5 seconds. For larger modpacks containing up to 200 mods, the system must generate the dependency graph in less than 10 seconds. For extreme cases containing between 200 and 500 mods, the system may require between 30 seconds and 2 minutes depending on graph complexity but must complete the process in a stable and predictable manner without system failure.

    Concurrent Requests:
    The backend must be designed to support multiple concurrent users performing dependency analysis and graph generation. Since the expected number of concurrent users depends on the final scope of the application, the system must maintain stable performance and predictable response times under moderate and peak usage scenarios.

    External Metadata Handling:
    The system must retrieve dependency and incompatibility data from external platforms such as CurseForge and Modrinth. The backend must handle rate limits, temporary service failures, incomplete responses, and data inconsistencies. When external services are unavailable, the system must use cached or previously processed data when possible and provide meaningful feedback to the user.

    Reliability and Availability:
    The system must maintain high availability during active usage. Automatic recovery mechanisms must handle network failures, API interruptions, and temporary service outages. The backend must prevent corruption of dependency and modpack data and ensure consistent graph construction results.

    Scalability:
    The architecture must support horizontal scaling to accommodate future increases in modpack size, graph complexity, and user demand. The backend must be modular to allow improvements and extensions without redesigning core components.

    Resource Usage:
    Memory and CPU usage must remain within acceptable limits during graph construction and metadata processing. Monitoring and logging must be implemented to detect performance bottlenecks and abnormal resource consumption.

    Stability and Graceful Degradation:
    Under overload conditions or limited resources, the system must degrade gracefully by prioritizing essential operations, applying request throttling, and avoiding system crashes.

    Data Integrity and Validation:
    Dependency data must be validated and normalized before graph construction. The system must ensure accurate representation of required, optional, and incompatible dependencies, as well as version constraints.


2.10 Software Architecture Design

3. Analytical

3.1 Concept Formation
    The Team A domain sketch illustrates the operation of the Mod Dependency Analyzer tool.
    - Based on these observations :
        - Mod : an artifact software uploaded by the user.
        - Dependecy : relationship that indicates that one mod requiere another.
        - DTO : abstraction used to carry mod and dependecy.
        - Dependency Graph — structured network formed by interconnected dependency relationships.
    - Grouping decisions: libraries needed and mods needed for a mod to work are grouped as Dependency because both are prerequisites.
    - Conflicts : dependecy referes to both libraries and mods, graph refres to a data structure and not a visual representation.

    The Team B analysis focuses on situations where declared dependencies must be located and associated in order to complete a mod configuration.
        -Required dependencies are often not included in the initial modpack configuration.
        -Missing components must be identified by consulting external mod repositories.
        -Resolving dependency issues involves not only recognizing relationships between mods, but also locating the components that satisfy those relationships.
        -Mod repositories function as reference environments that describe and provide the required mods.

    From these observations, dependency resolution is understood as a domain process connecting declared relationships with available components.
        -A dependency implies that the required mod exists in the ecosystem and must be discoverable.
        -Completing a configuration involves identifying and associating those components with the current modpack.
        -External sources are treated as part of the environment where dependencies are satisfied.

3.2 Validation
The team validates the requirements and domain understanding through structured scenario-based walkthroughs. These walkthroughs simulate realistic modpack configurations and are discussed collectively to identify ambiguities, missing edge cases, or incorrect assumptions about domain concepts such as Mod, Dependency, Incompatibility, and Modpack.

The goal of validation is not to obtain approval, but to ensure that the system-to-be correctly reflects the domain relationships and user needs.

Scenario 1: Missing Mandatory Dependency

Context:
A user uploads a modpack containing Mod A, which declares a mandatory dependency on Mod B. Mod B is not included in the uploaded modpack.

Walkthrough Steps:

1. The system parses metadata of all uploaded mods.
2. The declared dependencies of Mod A are extracted.
3. The system checks whether Mod B exists in the modpack.
4. The dependency graph is generated.
5. Missing dependency is visually highlighted.

Validation Outcome:
During walkthrough discussion, the team clarified the distinction between mandatory and optional dependencies. The requirement was refined to explicitly differentiate these cases and ensure that only mandatory dependencies trigger critical warnings.

Scenario 2: Circular Dependency Case

Context:
Mod A depends on Mod B, and Mod B depends on Mod A.

Walkthrough Steps:

1. Dependencies are parsed.
2. The graph is constructed.
3. The system analyzes graph structure for cycles.

Validation Outcome:
A new requirement was added to explicitly detect circular dependencies and notify users when a cycle exists. The concept of “graph as structural model” was distinguished from “graph as visual representation.”

3.3 Verification
Verification ensures that the Minecraft Mod Dependency Visualizer functions as intended and satisfies the specified requirements. The system will be verified through functional testing and user validation.

-Unit Testing: Individual components such as metadata extraction, and dependency parsing will be tested independently to ensure they produce correct and consistent results.

-Functional Testing: The system will be tested to confirm that a user can upload a mod file, generate a dependency graph, and receive accurate compatibility feedback.

-User Validation: A small group of users will test the application to verify usability, clarity of the visualization, and correctness of the compatibility results. Feedback will be used to improve system behavior and interface design.

-Performance Testing: The system will be evaluated to ensure it processes mod files within the required response time and maintains stability under multiple usage scenarios.

Verification will be considered successful when all functional requirements are met and no critical defects are present.
